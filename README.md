# Custom MVC

The project **Custom MVC** is PHP open-source web application MVC framework.  

## Table of Content

- [Installation and requirements](#installation-and-requirements)
- [Project structure](#project-structure)
- [Configuration and Setup](#configuration-and-setup)
- [Routes](#routes)
- [Controllers](#controllers)
  - [Defining a Controller Method](#defining-a-controller-method)
  - [Available Controller Methods](#available-controller-methods)
    - [json(array $data): Response](#jsonarray-data)
    - [render(string $view, array $params): Response](#renderstring-view-array-params)
    - [redirectToRoute(string $routeName, array $param): Response](#redirecttoroutestring-routename-array-param)
    - [redirect(string $url): Response](#redirectstring-url)
    - [generateUrl(string $routeName, array $param): string](#generateurlstring-routename-array-param)
- [Models](#models)
  - [Access the Database](#access-the-database)
    - [add(BaseModel $entity)](#add)
    - [delete(BaseModel $entity)](#delete)
    - [commit()](#commit)
  - [Available Model Methods - QueryBuilder class](#available-model-methods-querybuilder-class)
    - [all(): array](#all-array)
    - [first(): ?BaseModel](#first-basemodel)
    - [where(array $inputs): QueryBuilder](#wherearray-inputs)
    - [order(array ...$inputs): QueryBuilder](#orderarray-inputs)
- [Views](#views)
  - [Passing Data to Views](#passing-data-to-views)
  - [Passing an Array to a View](#passing-an-array-to-a-view)
- [Tests](#tests)
  - [Running all tests](#running-all-tests)
  - [Running a Specific Test File](#running-a-specific-test-file)
## Installation and requirements

Clone the repository from GitHub or download it as a ZIP file:
     ```
     git clone https://github.com/ManoelViktorovManev/Custom_MVC.git
     ```
   - If you downloaded the ZIP file, extract it to your desired directory.


This project requires **PHP 8** or above to run. Ensure that PHP is installed and accessible from the command line.

Make sure you are having database management system (DBMS) like  **MySQL, MariaDB, PostgreSQL** or others.


## Project structure

```
project-root/
├── config/              # Configurate routes files
│   └── routes.php
│   └── routes.yaml
│
├── controller/          # Directory for user-defined Controllers, each extending the BaseController
│   └── ExampleController.php
│
├── core/                # Core framework logic and base classes (e.g., BaseController, Router, BaseModel)
│   └── BaseController.php
│   └── Router.php
│   └── BaseModel.php
│
├── model/              # Directory for user-defined models (entities), each extending BaseModel
│   └── User.php
│
├── tests/               # Directory for unit and integration tests
│   └── ExampleTest.php
│
├── vendor/              # Composer dependencies (auto-generated by Composer, do not edit manually)
│
├── view/                # Directory for HTML view templates
│   └── layout.html
│   └── home.html
│
├── .env                 # Environment variables (e.g., database URL, timezone)
├── phpunit.xml          # PHPUnit configuration file for running tests
├── composer.json        # Composer configuration file listing dependencies and autoloading settings
└── README.md            # Project documentation
```
### Configuration and Setup

1. **Edit the Configuration File**: Open the `.env` file in the project’s root directory and configure the following values:
   - **`DATABASE_URL`**: Defines the database connection string.

Example **.env** file:
```.env
DATABASE_URL="scheme://user:pass@host:port/dbName"
``` 
2. **Start the Database**: Ensure your database application is running and accessible based on the DATABASE_URL configuration.

3. **Run the Server**: In the terminal, navigate to your **project directory** and start the PHP server:
```
php -S localhost:8080
```
Your application should now be accessible at http://localhost:8080.


## Routes
**Routes** can be defined differently depending on your **PHP** version. If you're using **PHP 8 or later**, you can define routes using **Attributes.** For older versions, you can define routes using configuration files.

### Defining Routes with Attributes (PHP 8+)
In PHP 8 and above, you can use **attributes** to define routes directly on controller methods. Each route attribute maps a specific URL pattern to a controller action, enabling clean and declarative routing.

There are four common route definitions:
```php
#[Route('/path')]                         // Basic route with a fixed path.
#[Route('/user/{id}')]                    // Route with a dynamic parameter, e.g., /user/123.
#[Route('/normal/test', name: 'param')]   // Named route, useful for generating URLs programmatically.
#[Route('/optional/{id?}')]               // Optional parameter, e.g., /optional/ or /optional/123.
```

Example:
```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Route;
use App\Core\Response;

class NewController extends BaseController
{
    #[Route('/normal')]
    public function testingNormalRoute()
    {
        // Example response
        return new Response('Test Normal Route');
    }

    #[Route('/test/{id}')]
    public function testingDynamicParameterRoute($id)
    {
        // Example response
        return new Response('Test with number ' . $id);
    }

    #[Route('/normal/test', name: 'param')]
    public function testingNamedRoute()
    {
        // Example response
        return new Response('Test text with Named Route');
    }

    #[Route('/optional/{id?}')]
    public function testingOptionalParameterRoute($id)
    {
        // Example response
        return new Response('Test with optional ' . $id);
    }
}

```
### Defining Routes with Config Files (For Older PHP Versions)
For PHP versions prior to **8**, routes can be defined in the **config** directory using either **routes.php or routes.yaml.** These files specify paths and their corresponding controllers and actions.

Example: **routes.php**
```php
# routes.php
<?php
namespace App\Config;

use App\Core\Router;
use App\Controller\NewController;
return function (Router $routes): void {
    // Syntax: $routes->add(route_name, path)->controller(ControllerClass::class, 'methodName');
    $routes->add('izwajdane12', '/minus/{param1}/{param2}')
        ->controller(NewController::class, 'minusNa2Chisla');
};
```
Example: **routes.yaml**
```yaml
# routes.yaml

# Format:
# route_name:
#   path: /your-path
#   controller: FullyQualified\ControllerName
#   action: methodName

info:
  path: /phpInfo
  controller: App\Controller\NewController
  action: phpInfo
```
Corresponding Controller:
```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Response;

class NewController extends BaseController
{
    public function minusNa2Chisla($param1, $param2): Response
    {
        return $this->json([
            'param1' => $param1,
            'param2' => $param2,
            'result' => $param1 - $param2
        ]);
    }

    public function phpInfo(): Response
    {
        return new Response(phpinfo());
    }
}

```
## Controllers
All controllers should be placed in the **/controller** directory. Each controller class should extend the **BaseController** class to gain access to the framework’s core functionality. Each controller method should return **Response** object.

### Defining a Controller Method
To create a route in a controller, annotate the method with a **#[Route(...)]** attribute. The framework will use this route to call the corresponding method when the URL matches.

Example Controller Method:

```php
<?php

namespace App\Controller;

use App\Core\BaseController;
use App\Core\Route;
use App\Core\Response;

class TestController extends BaseController
{
    #[Route('/normal/test')]
    public function testingNormalResponse()
    {
        // Example response
        return new Response('Test text');
    }
}
```
### Available Controller Methods
The **BaseController** provides several helper methods that make it easier to handle common tasks, such as returning JSON responses, rendering templates, and generating URLs.

### json(array $data): Response
Returns a JSON response. Use this to send structured data in JSON format. Returns **Response** object.
```php
#[Route('/jsonTest')]
public function testingJsonResponse()
{
   // Example response
   return $this->json(['status' => 'success', 'data' => $data]);
}
```

### render(string $view, array $params): Response
Renders a view template. This method takes the path to an HTML template and an optional array of variables to pass to the view. Returns **Response** object.

```php
#[Route('/renderTest')]
public function testingRenderResponse()
{
   // Example response
   return $this->render('home.html');
}

#[Route('/renderTest1')]
public function testingRenderResponse1()
{
   // Example response
   return $this->render('home.html', ['title' => 'Home Page']);
}
```

### redirectToRoute(string $routeName, array $param): Response
Redirects to a specified route by name. Useful for navigation within the application without hardcoding URLs. Returns **Response** object.
```php
#[Route('/redirectToRouteTest')]
public function testingRedirectToRouteResponse()
{
   // Example response
   return $this->redirectToRoute('param'); // it will redirect to 'param' name route which is '/normal/test' path
}

```

### redirect(string $url): Response
Redirects the user to a specified URL. This method is useful for external redirects or when you want full control over the URL. Returns **Response** object.
```php
#[Route('/redirectTest')]
public function testingRedirectResponse()
{
   // Example response
   return $this->redirect('https://example.com');
}

#[Route('/redirectTest1')]
public function testingRedirectResponse1()
{
   // Example response
   return $this->redirect('/path');
}
```

### generateUrl(string $routeName, array $param): string
Generates a URL for a named route. This method is particularly useful when you need to create a link to another route within the application, as it allows you to build URLs dynamically based on route names. Returns **String**.
```php
#[Route('/generateUrlTest')]
public function testingGenerateUrlResponse()
{
   // Example response
   $url = $this->generateUrl('user_profile', ['id' => 42]);
   return $this->redirect($url);
}
```

## Models
**Models (or Entities)** in this project are responsible for interacting with the database. They should be placed in the **/model** directory and must extend the **BaseModel** class to inherit the necessary database functionality.

Each model should include an **id** parameter, which serves as the primary identifier for each record.

Example Model:
```php
class User extends BaseModel
{
    private $id;
    private $name;
    private $email;

    // Getters and setters for properties...
    public function __construct($id = null, $name = '', $email = '')
    {
        $this->id = $id;
        $this->name = $name;
        $this->email = $email;
    }
}
```
In controller you can access it by this:
```php
#[Route('/normal/test')]
public function testingNormalResponse()
{
    // Example response
    $user = new User();
    $user->setName('test'); // setter
    $user->setEmail('test@gmail.com'); //setter
        
    return new Response('Test text');
}
```
### Access the Database
You can access the database by getting an instance from **DbManipulation class**. Here is an example:
```php
#[Route('/dbtest')]
public function testingNormalResponse()
{
    $db = new DbManipulation();
    // Example response
    $user = new User();
    $user->setName('test'); // setter
    $user->setEmail('test@gmail.com'); //setter
        
    return new Response('Test text');
}
```
By this class you can create, delete and update an existing model instance. You can call this methods:
### add(BaseModel $entity)
It adds an model instance to the queue for performance of insert or update element from Database.
```php
public function testUpdateUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $user->setName("fff");
        $db->add($user);
        $db->commit();
        return new Response("Successfuly updated an existing record");
    }

public function testInserteUser()
    {

        $db = new Db();
        $user = new User();
        $user->setName("Test");
        $user->setAge(123);
        $db->add($user);
        $db->commit();
        return new Response("Successfuly insert a new record");
    }
```
 
### delete(BaseModel $entity)
It adds an model instance to the queue for performance of delete element from Database.
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```

### commit()
It performs all inserted into the queue actions for update/insert and delete.
```php
public function testCommitUser()
    {

        $db = new Db();
        $db->commit();
        return new Response("Successfuly commited without doing something");
    }
```
### Available Model Methods - QueryBuilder class
The BaseModel provides several helper methods for interacting with the database. These methods simplify common database operations. You can access them via using the **QueryBuilder class** by calling it this way:
```php
class User;
user->query();
```
This class have several methods:
### all(): array
Retrieves all records from the associated table.
```php
$users = $user-query->all();
```

### first(): ?BaseModel
Get first finded record.
```php
$user = $user->query->first();
```
### where(array $inputs)
It performs an sql **WHERE** operation. It have three inputs in the array: **key, operation and value**. The first element is which **row** to look into the table. The allowed **operations** are: **'=', '!=', '<', '>', '<=', '>=' and 'LIKE'**. And the **value** is the looking value from the row.
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```
### order(array ...$inputs)
It performs an sql **ORDER BY** operation. By default it is **ASC**. It have two inputs in the array: **order by and how to order (it is not mandatory)**. It can take multiple arrays. 
```php
public function testUser()
    {

        $db = new Db();
        $user = new User();
        $user->query()->where(['name', '=', "NISAAN"])->order(["name","DESC"],["age"]).first();
        $db->delete($user);
        $db->commit();
        return new Response("Successfuly deleted");
    }
```
## Views

Views are responsible for the **HTML** structure and presentation of your application. All view files should be placed in the **/view** directory, and each view should be an **.html** file containing standard HTML markup.
```
<!-- /view/example.html -->
<h1>Welcome</h1>
<p>This is a sample HTML page.</p>
```

### Passing Data to Views
You can pass data from the controller to the view using the **render()** method. Within the HTML, use **{{ parameter }}** syntax to display dynamic data provided by the controller.

Example:

Controller Method:
```php
#[Route('/greeting')]
public function showGreeting()
{
    $name = "John";
    $content = "Welcome to our website!";
    return $this->render('greeting.html', ['name' => $name, 'content' => $content]);
}
```
View File (/view/greeting.html):
```
<h1>Hello, {{ name }}!</h1>
<p>{{ content }}</p>
```
In this example, **{{ name }}** and **{{ content }}** in the view file are placeholders that will be replaced by the values passed in the **render()** method **('name' => $name and 'content' => $content)**.

### Passing an Array to a View
Suppose you have a controller method where you want to pass an associative array to a view:
```php
#[Route('/user/profile')]
public function showUserProfile()
{
    // Define an associative array with user data
    $user = [
        'id' => 1,
        'name' => 'John Doe',
        'email' => 'john@example.com'
    ];

    // Render the view and pass the array as a parameter
    return $this->render('profile.html', ['user' => $user]);
}
```
Now, in the view, you can access the properties of the user array by referencing **{{ user.key }}** for each key in the array:
```html
<h1>User Profile</h1>
<p>User ID: {{ user.id }}</p>
<p>Name: {{ user.name }}</p>
<p>Email: {{ user.email }}</p>
```
## Tests
In this MVC we have build in tests, which it can be find inside **/tests** folder. 

### Running All Tests
To run all tests, navigate to your project root in the terminal and execute:
```
vendor/bin/phpunit 
```
This command will automatically discover and run all test files in the **/tests** directory based on the configuration defined in **phpunit.xml.**

### Running a Specific Test File
To run a specific test file (e.g., a custom test), use the following command:
```
vendor/bin/phpunit path/to/YourTestFile.php
```
Example:
```
vendor/bin/phpunit ./tests/CustomPHPTest.php
```
```